{"ast":null,"code":"import { isBigNumber, isCollection, isNumber } from '../../utils/is.js';\nimport { flatten } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { createApply } from '../matrix/apply.js';\nvar name = 'quantileSeq';\nvar dependencies = ['typed', 'add', 'multiply', 'partitionSelect', 'compare', 'isInteger'];\nexport var createQuantileSeq = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    add,\n    multiply,\n    partitionSelect,\n    compare,\n    isInteger\n  } = _ref;\n  /**\n   * Compute the prob order quantile of a matrix or a list with values.\n   * The sequence is sorted and the middle value is returned.\n   * Supported types of sequence values are: Number, BigNumber, Unit\n   * Supported types of probability are: Number, BigNumber\n   *\n   * In case of a multidimensional array or matrix, the prob order quantile\n   * of all elements will be calculated.\n   *\n   * Syntax:\n   *\n   *     math.quantileSeq(A, prob[, sorted])\n   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])\n   *     math.quantileSeq(A, N[, sorted])\n   *\n   * Examples:\n   *\n   *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4\n   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]\n   *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]\n   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4\n   *\n   * See also:\n   *\n   *     median, mean, min, max, sum, prod, std, variance\n   *\n   * @param {Array, Matrix} data                A single matrix or Array\n   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is\n   *                                            the amount of evenly distributed steps of\n   *                                            probabilities; only one of these options can\n   *                                            be provided\n   * @param {Boolean} sorted=false              is data sorted in ascending order\n   * @return {Number, BigNumber, Unit, Array}   Quantile(s)\n   */\n\n  var apply = createApply({\n    typed,\n    isInteger\n  });\n  /**\n   * Check if array value types are valid, throw error otherwise.\n   * @param {number | BigNumber | Unit} x\n   * @param {number | BigNumber | Unit} x\n   * @private\n   */\n  var validate = typed({\n    'number | BigNumber | Unit': function numberBigNumberUnit(x) {\n      return x;\n    }\n  });\n  return typed(name, {\n    'Array|Matrix, number|BigNumber|Array': (data, prob) => quantileSeq(data, prob, false),\n    'Array|Matrix, number|BigNumber|Array, boolean': quantileSeq,\n    'Array|Matrix, number|BigNumber|Array, number': (data, prob, dim) => _quantileSeqDim(data, prob, false, dim),\n    'Array|Matrix, number|BigNumber|Array, boolean, number': (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim)\n  });\n  function _quantileSeqDim(data, prob, sorted, dim) {\n    // return [1.3, 1.2]\n    return apply(data, dim, x => quantileSeq(x, prob, sorted));\n  }\n  function quantileSeq(data, probOrN, sorted) {\n    var probArr, dataArr, one;\n    if (arguments.length < 2 || arguments.length > 3) {\n      throw new SyntaxError('Function quantileSeq requires two or three parameters');\n    }\n    if (isCollection(data)) {\n      sorted = sorted || false;\n      if (typeof sorted === 'boolean') {\n        dataArr = data.valueOf();\n        if (isNumber(probOrN)) {\n          if (probOrN < 0) {\n            throw new Error('N/prob must be non-negative');\n          }\n          if (probOrN <= 1) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return _quantileSeq(dataArr, probOrN, sorted);\n          }\n          if (probOrN > 1) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!isInteger(probOrN)) {\n              throw new Error('N must be a positive integer');\n            }\n            var nPlusOne = probOrN + 1;\n            probArr = new Array(probOrN);\n            for (var i = 0; i < probOrN;) {\n              probArr[i] = _quantileSeq(dataArr, ++i / nPlusOne, sorted);\n            }\n            return probArr;\n          }\n        }\n        if (isBigNumber(probOrN)) {\n          var BigNumber = probOrN.constructor;\n          if (probOrN.isNegative()) {\n            throw new Error('N/prob must be non-negative');\n          }\n          one = new BigNumber(1);\n          if (probOrN.lte(one)) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return new BigNumber(_quantileSeq(dataArr, probOrN, sorted));\n          }\n          if (probOrN.gt(one)) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!probOrN.isInteger()) {\n              throw new Error('N must be a positive integer');\n            }\n\n            // largest possible Array length is 2^32-1\n            // 2^32 < 10^15, thus safe conversion guaranteed\n            var intN = probOrN.toNumber();\n            if (intN > 4294967295) {\n              throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');\n            }\n            var _nPlusOne = new BigNumber(intN + 1);\n            probArr = new Array(intN);\n            for (var _i = 0; _i < intN;) {\n              probArr[_i] = new BigNumber(_quantileSeq(dataArr, new BigNumber(++_i).div(_nPlusOne), sorted));\n            }\n            return probArr;\n          }\n        }\n        if (isCollection(probOrN)) {\n          // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])\n          var probOrNArr = probOrN.valueOf();\n          probArr = new Array(probOrNArr.length);\n          for (var _i2 = 0; _i2 < probArr.length; ++_i2) {\n            var currProb = probOrNArr[_i2];\n            if (isNumber(currProb)) {\n              if (currProb < 0 || currProb > 1) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else if (isBigNumber(currProb)) {\n              one = new currProb.constructor(1);\n              if (currProb.isNegative() || currProb.gt(one)) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else {\n              throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n            }\n\n            probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);\n          }\n          return probArr;\n        }\n        throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n      }\n\n      throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n    }\n\n    throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n  }\n\n  /**\n   * Calculate the prob order quantile of an n-dimensional array.\n   *\n   * @param {Array} array\n   * @param {Number, BigNumber} prob\n   * @param {Boolean} sorted\n   * @return {Number, BigNumber, Unit} prob order quantile\n   * @private\n   */\n  function _quantileSeq(array, prob, sorted) {\n    var flat = flatten(array);\n    var len = flat.length;\n    if (len === 0) {\n      throw new Error('Cannot calculate quantile of an empty sequence');\n    }\n    if (isNumber(prob)) {\n      var _index = prob * (len - 1);\n      var _fracPart = _index % 1;\n      if (_fracPart === 0) {\n        var value = sorted ? flat[_index] : partitionSelect(flat, _index);\n        validate(value);\n        return value;\n      }\n      var _integerPart = Math.floor(_index);\n      var _left;\n      var _right;\n      if (sorted) {\n        _left = flat[_integerPart];\n        _right = flat[_integerPart + 1];\n      } else {\n        _right = partitionSelect(flat, _integerPart + 1);\n\n        // max of partition is kth largest\n        _left = flat[_integerPart];\n        for (var i = 0; i < _integerPart; ++i) {\n          if (compare(flat[i], _left) > 0) {\n            _left = flat[i];\n          }\n        }\n      }\n      validate(_left);\n      validate(_right);\n\n      // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n      return add(multiply(_left, 1 - _fracPart), multiply(_right, _fracPart));\n    }\n\n    // If prob is a BigNumber\n    var index = prob.times(len - 1);\n    if (index.isInteger()) {\n      index = index.toNumber();\n      var _value = sorted ? flat[index] : partitionSelect(flat, index);\n      validate(_value);\n      return _value;\n    }\n    var integerPart = index.floor();\n    var fracPart = index.minus(integerPart);\n    var integerPartNumber = integerPart.toNumber();\n    var left;\n    var right;\n    if (sorted) {\n      left = flat[integerPartNumber];\n      right = flat[integerPartNumber + 1];\n    } else {\n      right = partitionSelect(flat, integerPartNumber + 1);\n\n      // max of partition is kth largest\n      left = flat[integerPartNumber];\n      for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {\n        if (compare(flat[_i3], left) > 0) {\n          left = flat[_i3];\n        }\n      }\n    }\n    validate(left);\n    validate(right);\n\n    // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n    var one = new fracPart.constructor(1);\n    return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart));\n  }\n});","map":{"version":3,"names":["isBigNumber","isCollection","isNumber","flatten","factory","createApply","name","dependencies","createQuantileSeq","_ref","typed","add","multiply","partitionSelect","compare","isInteger","apply","validate","numberBigNumberUnit","x","Array|Matrix, number|BigNumber|Array","data","prob","quantileSeq","Array|Matrix, number|BigNumber|Array, number","dim","_quantileSeqDim","Array|Matrix, number|BigNumber|Array, boolean, number","sorted","probOrN","probArr","dataArr","one","arguments","length","SyntaxError","valueOf","Error","_quantileSeq","nPlusOne","Array","i","BigNumber","constructor","isNegative","lte","gt","intN","toNumber","_nPlusOne","_i","div","probOrNArr","_i2","currProb","TypeError","array","flat","len","_index","_fracPart","value","_integerPart","Math","floor","_left","_right","index","times","_value","integerPart","fracPart","minus","integerPartNumber","left","right","_i3"],"sources":["/home/dulphy/WorkSpace/reactjs/calculadora/node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js"],"sourcesContent":["import { isBigNumber, isCollection, isNumber } from '../../utils/is.js';\nimport { flatten } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { createApply } from '../matrix/apply.js';\nvar name = 'quantileSeq';\nvar dependencies = ['typed', 'add', 'multiply', 'partitionSelect', 'compare', 'isInteger'];\nexport var createQuantileSeq = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    add,\n    multiply,\n    partitionSelect,\n    compare,\n    isInteger\n  } = _ref;\n  /**\n   * Compute the prob order quantile of a matrix or a list with values.\n   * The sequence is sorted and the middle value is returned.\n   * Supported types of sequence values are: Number, BigNumber, Unit\n   * Supported types of probability are: Number, BigNumber\n   *\n   * In case of a multidimensional array or matrix, the prob order quantile\n   * of all elements will be calculated.\n   *\n   * Syntax:\n   *\n   *     math.quantileSeq(A, prob[, sorted])\n   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])\n   *     math.quantileSeq(A, N[, sorted])\n   *\n   * Examples:\n   *\n   *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4\n   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]\n   *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]\n   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4\n   *\n   * See also:\n   *\n   *     median, mean, min, max, sum, prod, std, variance\n   *\n   * @param {Array, Matrix} data                A single matrix or Array\n   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is\n   *                                            the amount of evenly distributed steps of\n   *                                            probabilities; only one of these options can\n   *                                            be provided\n   * @param {Boolean} sorted=false              is data sorted in ascending order\n   * @return {Number, BigNumber, Unit, Array}   Quantile(s)\n   */\n\n  var apply = createApply({\n    typed,\n    isInteger\n  });\n  /**\n   * Check if array value types are valid, throw error otherwise.\n   * @param {number | BigNumber | Unit} x\n   * @param {number | BigNumber | Unit} x\n   * @private\n   */\n  var validate = typed({\n    'number | BigNumber | Unit': function numberBigNumberUnit(x) {\n      return x;\n    }\n  });\n  return typed(name, {\n    'Array|Matrix, number|BigNumber|Array': (data, prob) => quantileSeq(data, prob, false),\n    'Array|Matrix, number|BigNumber|Array, boolean': quantileSeq,\n    'Array|Matrix, number|BigNumber|Array, number': (data, prob, dim) => _quantileSeqDim(data, prob, false, dim),\n    'Array|Matrix, number|BigNumber|Array, boolean, number': (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim)\n  });\n  function _quantileSeqDim(data, prob, sorted, dim) {\n    // return [1.3, 1.2]\n    return apply(data, dim, x => quantileSeq(x, prob, sorted));\n  }\n  function quantileSeq(data, probOrN, sorted) {\n    var probArr, dataArr, one;\n    if (arguments.length < 2 || arguments.length > 3) {\n      throw new SyntaxError('Function quantileSeq requires two or three parameters');\n    }\n    if (isCollection(data)) {\n      sorted = sorted || false;\n      if (typeof sorted === 'boolean') {\n        dataArr = data.valueOf();\n        if (isNumber(probOrN)) {\n          if (probOrN < 0) {\n            throw new Error('N/prob must be non-negative');\n          }\n          if (probOrN <= 1) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return _quantileSeq(dataArr, probOrN, sorted);\n          }\n          if (probOrN > 1) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!isInteger(probOrN)) {\n              throw new Error('N must be a positive integer');\n            }\n            var nPlusOne = probOrN + 1;\n            probArr = new Array(probOrN);\n            for (var i = 0; i < probOrN;) {\n              probArr[i] = _quantileSeq(dataArr, ++i / nPlusOne, sorted);\n            }\n            return probArr;\n          }\n        }\n        if (isBigNumber(probOrN)) {\n          var BigNumber = probOrN.constructor;\n          if (probOrN.isNegative()) {\n            throw new Error('N/prob must be non-negative');\n          }\n          one = new BigNumber(1);\n          if (probOrN.lte(one)) {\n            // quantileSeq([a, b, c, d, ...], prob[,sorted])\n            return new BigNumber(_quantileSeq(dataArr, probOrN, sorted));\n          }\n          if (probOrN.gt(one)) {\n            // quantileSeq([a, b, c, d, ...], N[,sorted])\n            if (!probOrN.isInteger()) {\n              throw new Error('N must be a positive integer');\n            }\n\n            // largest possible Array length is 2^32-1\n            // 2^32 < 10^15, thus safe conversion guaranteed\n            var intN = probOrN.toNumber();\n            if (intN > 4294967295) {\n              throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');\n            }\n            var _nPlusOne = new BigNumber(intN + 1);\n            probArr = new Array(intN);\n            for (var _i = 0; _i < intN;) {\n              probArr[_i] = new BigNumber(_quantileSeq(dataArr, new BigNumber(++_i).div(_nPlusOne), sorted));\n            }\n            return probArr;\n          }\n        }\n        if (isCollection(probOrN)) {\n          // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])\n          var probOrNArr = probOrN.valueOf();\n          probArr = new Array(probOrNArr.length);\n          for (var _i2 = 0; _i2 < probArr.length; ++_i2) {\n            var currProb = probOrNArr[_i2];\n            if (isNumber(currProb)) {\n              if (currProb < 0 || currProb > 1) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else if (isBigNumber(currProb)) {\n              one = new currProb.constructor(1);\n              if (currProb.isNegative() || currProb.gt(one)) {\n                throw new Error('Probability must be between 0 and 1, inclusive');\n              }\n            } else {\n              throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n            }\n\n            probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);\n          }\n          return probArr;\n        }\n        throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n      }\n\n      throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n    }\n\n    throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed-function\n  }\n\n  /**\n   * Calculate the prob order quantile of an n-dimensional array.\n   *\n   * @param {Array} array\n   * @param {Number, BigNumber} prob\n   * @param {Boolean} sorted\n   * @return {Number, BigNumber, Unit} prob order quantile\n   * @private\n   */\n  function _quantileSeq(array, prob, sorted) {\n    var flat = flatten(array);\n    var len = flat.length;\n    if (len === 0) {\n      throw new Error('Cannot calculate quantile of an empty sequence');\n    }\n    if (isNumber(prob)) {\n      var _index = prob * (len - 1);\n      var _fracPart = _index % 1;\n      if (_fracPart === 0) {\n        var value = sorted ? flat[_index] : partitionSelect(flat, _index);\n        validate(value);\n        return value;\n      }\n      var _integerPart = Math.floor(_index);\n      var _left;\n      var _right;\n      if (sorted) {\n        _left = flat[_integerPart];\n        _right = flat[_integerPart + 1];\n      } else {\n        _right = partitionSelect(flat, _integerPart + 1);\n\n        // max of partition is kth largest\n        _left = flat[_integerPart];\n        for (var i = 0; i < _integerPart; ++i) {\n          if (compare(flat[i], _left) > 0) {\n            _left = flat[i];\n          }\n        }\n      }\n      validate(_left);\n      validate(_right);\n\n      // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n      return add(multiply(_left, 1 - _fracPart), multiply(_right, _fracPart));\n    }\n\n    // If prob is a BigNumber\n    var index = prob.times(len - 1);\n    if (index.isInteger()) {\n      index = index.toNumber();\n      var _value = sorted ? flat[index] : partitionSelect(flat, index);\n      validate(_value);\n      return _value;\n    }\n    var integerPart = index.floor();\n    var fracPart = index.minus(integerPart);\n    var integerPartNumber = integerPart.toNumber();\n    var left;\n    var right;\n    if (sorted) {\n      left = flat[integerPartNumber];\n      right = flat[integerPartNumber + 1];\n    } else {\n      right = partitionSelect(flat, integerPartNumber + 1);\n\n      // max of partition is kth largest\n      left = flat[integerPartNumber];\n      for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {\n        if (compare(flat[_i3], left) > 0) {\n          left = flat[_i3];\n        }\n      }\n    }\n    validate(left);\n    validate(right);\n\n    // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n    var one = new fracPart.constructor(1);\n    return add(multiply(left, one.minus(fracPart)), multiply(right, fracPart));\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}